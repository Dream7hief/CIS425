Study guide

- Grammars. Questions 2 and 3 from Assignment #1
Language generated by a grammar
Design a grammar that generates a language

 

- Lambda calculus. Questions 1 and 2 from Assignment #2
Free and Bound variables
Renaming

 

- Racket. Assignment #3
Quote and Quasiquote

 

- Type Checking. Assignment #4
Represent types and expressions as values of the datatypes typ and term
Give the result of type checking a term, for example,
typechecking the expression fn x:'a => x returns the type 'a -> 'a

 

- Type Inference. Assignment #5
Draw the internal representation of ML expressions
Write down the constraints
Derive the final type


- Memory Management. Assignment #6
Drawn the activation records

 

- Parameter Passing Techniques. Assignment #6
call-by-value; call-by-reference ; call-by-value-result

Focus on the example
var x : integer;
x := 0;
procedure p(y : integer)
begin
y := 1;
x := 0;
end;
p(x);

What is the value of x according to the three parameter passing techniques?

 

- Exceptions. Assignment #8
Raising and handling exceptions; remember that when an exception is raised,
one looks for the handler in the current activation record, if no handler
is found then one looks for the handler in the activation record of the
caller.

Consider:

exception X;
let
fun f y = raise X
fun g h = (h 1) handle X => 2
in (g f) handle X => 4
end;

When function f is called with 1 the exception X is raised.
The activation record associated to (f 1) doesn't have any handler for
exception X. Thus, the handler is searched in the caller, which provides
the handle for X, thus 2 is returned from (f 1).

Consider another example:
exception X;
let
fun f y = raise X
fun g h = (h 1) handle X => raise X
in (g f) handle X => 4
end;

Do you understand why the answer is 4?

 

- Continuation Passing Style (CPS). Assignment #8
In CPS a function never returns to the caller. Consider the following
function

fun fact n = if n = 1 then 1 else n * fact (n-1)

Consider the following trace:

fact 3
3 * fact 2
3 * 2 * fact 1
3 * 2 * 1

Note how the calls (fact 2) and (fact 1) return to the caller to
perform the rest of the computation. As discussed in class, factorial
is not tail-recursive, i.e. the recursive call is not the last operation
to be performed.
How do we write factorial in tail recursive way? One way, is to write
the function in CPS form as follows:

fun fact_iter n k = if n = 1 then k 1 else fact_iter (n-1) (fn v=>k (n*v))

The previous invocation becomes:

fact_iter 3 (fn x => x)
fact_iter 2 (fn v => (fn x=>x)(3*v))
fact_iter 1 (fn v => (fn v => (fn x=>x)(3*v)) (2*v))
(fn v => (fn v => (fn x=>x)(3*v)) (2*v)) 1
(fn v => (fn x=>x)(3*v)) (2*1)
(fn v => (fn x=>x)(3*v)) 2
(fn x=>x)(3*2)
(fn x=>x) 6
6

Think on how to write a function in continuation-passing style which sums
all the elements of a list. You can return 0 if the list is empty


- Streams in Haskell and ML - Assignment #9

How to define the infinite list of natural numbers starting from n
in Haskell

nats n = .........

How to define the function called nth which returns the nth
element of a list in Haskell. The result of
nth 5 (nats 0)
should be 4

Suppose you define natList in SML as:
fun nats n = n :: (nats (n+1))
What is the result of nats 0 in SML?

How to define nats and the function nth in SML
so that the result of (nth 5 (nats 0) is 4.


- Error Monad. Assignment #10
How to define the return and bind operation of the error monad


For extra credit: call-by-value and call-by-name with static and dynamic scope
